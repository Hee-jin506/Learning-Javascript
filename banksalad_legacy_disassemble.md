# 뱅크샐러드의 레거시 서비스 분해 과정

> 출처 : https://blog.banksalad.com/tech/how-banksalald-decomposes-legacy-services/

뱅크 샐러드는 앱 출시 이후 3년 동안 폭발적인 성장을 겪은 탓에 **서비스의 기술적인 복잡도**도 급격히 높아졌다. 

- 뱅크 샐러드는 원래 `마이크로 서비스`로 시작했던 jg이름의 서버(레거시 서비스)에서 시작하여 주먹 구구식 기능 추가가 이뤄졌고, 현재는 사실상 뱅크샐러드의 핵심 비즈니스 로직을 담당하는 거대한 `모놀리식 서버`가 되었다.

> - `마이크로 서비스`
>   소프트웨어를 구축하기 위한 아키텍쳐이자, 하나의 접근 방식으로 애플리케이션을 상호 독립적인 최소 구성 요소로 분할한다. 다수의 애플리케이션 간의 유사한 프로세스를 공유하는 기능을 중시한다. 또한 클라우드 네이티브 모델 구현을 위해 애플리케이션 개발을 최적화하는데 필요한 주요 구성 요소이다.
> - `모놀리식 아케틱쳐`
>   모든 요소를 하나의 애플리케이션에 구축하는 접근 방식이다. 모놀리식 아키텍쳐는 전체 어플리케이션을 하나의 통합된 패키지로 개발 배포한다.
>
> ![?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F49wTn%2FbtqASzgr8wR%2FjLuZ4oQHoMyv4CnkeTxBC0%2Fimg](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F49wTn%2FbtqASzgr8wR%2FjLuZ4oQHoMyv4CnkeTxBC0%2Fimg.png)

- 그런데 더욱 심각한 문제는 이 레거시 서비스의 비즈니스 로직을 정확히 아는 사람이 없다는 점이었다. 기획 문서는 있었지만 급변하는 시장 상황 속에서 낡아버린 기획 문서가 대부분이었고, 단위 테스트 커버리지 자체는 높았지만 가장 까다로운 비즈니스 로직에 대한 테스트가 빈약해서 서비스의 동작에 관한 자신감이 항상 부족했다.
- 설상 가상으로 Python과 MongoDB 기반으로 운영되던 서비스여서 유연한 타입 체계를 기반으로 빠르게 아이디어를 실험하기엔 최적화되어있었으나 이렇게 복잡도가 눈덩이처럼 불어난 상태에서는 오히려 그 유연함이 성장의 발목을 잡았다.
- 따라서 고민 끝에 레거시 서비스가 가진 복잡도를 제거해야했고, 이를 위해서 레거시 서비스를 분해하는 방법을 택했다. **복잡도가 높은 서비스 하나를 복잡도가 낮은 서비스 여럿으로 해체하는 것이다.** 



## 서비스 구조 결정

- 레거시 서비스 분해 과정에서 관건은 어떻게 서비스를 나눌지에 관한 것이었는데, 이 프로젝트 자체가 모든 면에서 큰 비용이 따랐다. 따라서 신속하게 진행할 수 있도록 설계를 하는 시간도 촉박할 수 밖에 없었다. 그런데 그 누구도 이 레거시 서비스의 비즈니스 로직을 아주 세밀한 수준까지 알지 못했고, 모든 요구사항을 정확히 파악한 후에 올바른 설계를 하는 것은 너무 많은 시간이 필요해보였다. 따라서 개발 팀은 불확실성의 영역을 인지하는 상태에서 서비스 구조를 결정하기로 했다.
- 불확실성을 제어하기 위해 **"개발자가 확실히 알고 있는 무언가"**로부터 생각을 시작했고, 서비스의 구조를 **"뱅크 샐러드의 개발 조직이 일하는 방식"**을 기준으로 생각해보았다.
- 뱅크샐러드는 사용자 임팩트를 만들어낼 수 있는 최적의 규모와 구성을 갖춘 조직 단위인 `스쿼드` 체계로 움직인다. 한 스쿼드당 8명 정도 규모의 조직으로 뱅크샐러드의 각 기능에 대한 오너십을 갖고 주도적으로 실험하고 학습한다. 따라서 이 스쿼드들이 **기술적으로도 독립된 오너십**을 갖고 주도적으로 실험해볼 수 있도록 서비스 구조를 제품, 기술, 조직 구조상으로 연결된 **15개의 마이크로 서비스 구조**를 도출할 수 있었다.



## 본격적인 분해 과정 / 방법

- 프로젝트의 복잡도를 제어 : 복잡도를 제어하기 위해 어떻게든 문제를 단순화하여 문제의 난이도를 낮추는 접근을 다음과 같이 취했다.

  - 섀도잉 : 문제를 단순화하여 프로젝트의 가시성을 확보하기 위해, 레거시 서비스와 신규 서비스의 응답이 얼마나 일치하는 지 측정하는 문제로 전환![shadowing](https://blog.banksalad.com/static/d4e54b093adb211fb67117dbe2a23c86/97a96/shadowing.png)

    같은 요청에 대해 레거시 서비스의 응답과 신규서비스의 응답의 일치 여부를 판단해서 `스탯(stat)`을 찍도록 처리했고, 실제로 어떤 값이 어떻게 다른지는 `키바나(Kibana)`를 통해 검색할 수 있도록 로깅했다.

    > 키바나란?
    >
    > 브라우저 인터페이스를 이용, 많은 데이터를 쉽게 검색, 시각화 탐색할 수 있는 오픈소스 분석 및 시각화 도구
    >
    > 참고 : https://www.elastic.co/kr/kibana

    ```java
    // A
    {
      "name": "banksalad",
      "favorites": ["tech", "data", "product"],
      "url": "https://career.banksalad.com/jobs/?category=tech",
    }
    
    // B
    {
      "name": "banksalad",
      "favorites": ["tech", "impact", "transparency"],
    }
    ```

    레거시 서비스가 A와 같은 JSON을 응답으로 반환하고, 새로운 서비스가 같은 요청에 대해 B와 같은 JSON을 응답으로 반환하면 두 서비스의 응답이 일치하지 않는다고 판단하며 이 불일치를 디프(diff)라고 칭한다.

    이러한 디프가 발생하면 기존 서비스를 새로운 서비스로 대체할 때 버그로 이어지므로, 디프를 0으로 만드는 것이 목표이다. 기존 서비스의 오나전한 대체, 누구도 눈치채지 못할만큼 기존과 완전히 동일하게 동작하도록 레거시 서비스를 분해하는 것이 이번 프로젝트의 목표가 되는 것이며, 최종적으로 발생하는 디프가 핵심 결과(key result)에 해당한다.

    > JSON(JavaScript Object Notation)이란?
    >
    > - 데이터를 저장하거나 전송할 때 많이 사용되는 경량의 DATA 교환 형식
    > - Javascript에서 객체를 만들 때 사용하는 표현식
    > - 최근에는 JSON 표현식의 높은 가독성과 작은 용량 덕에, XML을 대체하여 데이터 전송 등에 많이 사용된다.
    > - JSON은 데이터 포맷일 뿐이며 어떤 통신 방법도 프로그래밍 문법도 아닌 단순히 데이터를 표시하는 표현 방법일 뿐이다.
    >
    > 출처 : https://velog.io/@surim014/JSON%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80

  - 프로젝트의 목표가 아닌 것을 분명히 하고 원칙에 집중

  - 매일, 필요하다면 두시간에 한번씩 만나 상황 공유

  

